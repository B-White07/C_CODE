#define _CRT_SECURE_NO_WARNINGS 1
#include"utils.h"
struct Book
{
	char name[20];
	char id[20];
	double price;
};

int main()
{
	/*
		一、操作符详解
		操作符分类：
		1.算术操作符	2.移位操作符	3.位运算符		4.赋值运算符	5.单目操作符	6.关系操作符
		7.逻辑操作符	8.条件操作符	9.逗号表达式	10.下标引用、函数调用和结构成员
	*/
	//1.算术操作符： +	-	*	/	%
	// '/'若要得到浮点数，操作数必须有一个为浮点数。否则即使用浮点类型来接收，仍然会得到整形。
	//	浮点数(3.0  5.0等常量，若定义变量，定义为什么就是什么)默认为double类型，可以在结尾加f来变成float
	//float a = 1;
	//printf("%d", sizeof(a));

	// '%'两个操作数必须是整数
	/*int a = 7 % 3.0;
	printf("%d\n", a);*/

	//2.移位操作符：	<<左移		>>右移
	//负整数的三种二进制表示：
	//原码：直接根据数值写出的二进制序列
	//反码：原码符号位不变，其余位按位取反
	//补码(计算机中存储的格式)：反码加1
	//正整数的三个码相同
	//int a = 10;
	////把a的二进制位左移一位，左边丢弃，右边补0。	其实就是乘2
	//int b = a << 1;
	////把a的二进制位右移，右边丢弃
	////算术右移：左边补原符号位			逻辑右移：左边补0
	//int c = a >> 2;//把a的二进制位右移一位，右边丢弃，左边补符号位。	当前为算术右移
	//printf("%d\n", a);//移位后a不变					Q:正数左移右移相当于乘除2，负数呢？
	//printf("%d\n", b);
	//printf("%d\n", c);

	//3.位操作符(操作数必须是整数)：	&	|	^按位异或		--		均操作二进制位
	//int a = 3;
	//int b = 5;
	//int c1 = a & b;
	//int c2 = a | b;
	//int c3 = a ^ b;
	//printf("%d\n", c1);
	//printf("%d\n", c2);
	//printf("%d\n", c3);
	//交换变量值，不定义新变量
	//int a = 3;
	//int b = 5;
	//printf("交换前a = %d,b = %d\n", a, b);
	////a = a + b;	//数值太大可能会溢出
	////b = a - b;
	////a = a - b;
	////异或	0 ^ a = a		a ^ a = 0
	//a = a ^ b;
	//b = a ^ b;//b = a ^ b ^ b = a
	//a = a ^ b;//a = a ^ b ^ a ^ b ^ b = b
	//printf("交换后a = %d,b = %d", a, b);

	//int a = 0;
	//scanf("%d", &a);
	//printf("%d",numOfBin(a));

	//改变a的二进制第5位
	//int a = 13;
	//a = a | (1 << 4);
	//printf("%d\n", a);
	////再改变a的二进制第5位
	//a = a & ~(1 << 4);
	//printf("%d\n", a);

	//4.赋值操作符：	>>=		<<=		&=		|=		^=	
	//5.单目操作符：	！		-		+		&		sizeof		~(按位取反，包括符号位)		--		++		*（解引用）		(类型)
	//int a = 10;
	//int arr[10] = { 0 };
	//printf("%d\n", sizeof a);
	//printf("%d\n", sizeof arr);//sizeof计算变量的时候可以省略括号，但计算关键字的时候不可以省略。
	//printf("%d\n", sizeof(int [10]));//int [10]为数组的类型（即数组类型为去掉数组名剩下的部分）
	//short s = 5;
	//int a = 10;
	//printf("%d\n", sizeof(s = a + 2));//sizeof括号中放的表达式不参与运算！sizeof是在编译期间处理的，而表达式是在运行期间处理的
	////sizeof编译过后，此段代码就已经无效了，编译只是看一下括号内的最终类型，而并没有实际运算。
	//printf("%d\n", s);
	//	&	*(解引用/间接访问，通过地址找到其所指向的对象)

	//6.强制类型转换
	//int a = (int)3.14;
	//printf("%d", a);

	//7.关系操作符：就是比较大小。	注意，有时比较相等不能使用==，例如比较字符串
	//8.逻辑操作符：	&&(若左边为假，右边不参与计算)		||(若左边为真，右边不参与计算)
	//int i = 0, a = 0, b = 2, c = 3, d = 4;
	////i = a++ && ++b && d++;
	//i = a++ || ++b || d++;
	//printf("a = %d\nb = %d\nc = %d\nd = %d\n", a, b, c, d);

	//9.条件操作符(三目操作符)
	//10.逗号表达式，从左向右依次计算，整个表达式的值为最后一个表达式的值。
	//下标引用操作符[]：eg 数组取元素arr[4]，操作数为arr和4。
	//函数调用操作符()：eg sum(a,b)，操作数：sum、a、b
	//结构成员访问操作符 ->	. 
	//	.	访问结构体成员变量：结构体变量名.成员名
	//struct Book book = { "理想国","A21546",80.25 };
	//struct Book* pb = &book;
	//printf("书名：%s\n", book.name);
	//printf("书号：%s\n", book.id);
	//printf("价格：%lf\n", book.price);

	//printf("书名：%s\n", (*pb).name);
	//printf("书号：%s\n", (*pb).id);
	//printf("价格：%lf\n", (*pb).price);

	////	->	通过指针访问结构体的成员变量：结构体指针->成员名
	//printf("书名：%s\n", pb->name);
	//printf("书号：%s\n", pb->id);
	//printf("价格：%lf\n", pb->price);

	/*
		二、表达式求值
		表达式求值的顺序一部分是有操作符的优先级和结合性决定，有些表达式的操作数在求值的过程中可能需要转换为其它类型。
		1.隐式类型转换：1.整型提升	2.算术转换
		2.操作符属性
	*/
	//1.整型提升：表达式的整型运算要在CPU的相应运算器件内执行，CPU内整型运算器(ALU)的操作数的字节长度
	//一般就是int的字节长度，同时也是CPU的通用寄存器的长度。
	//因此，即使两个char类型的相加，在CPU执行时实际上也要先转换为CPU内整型操作数的标准长度。
	//通用CPU(general - purpose CPU）是难以直接实现两个8比特字节直接相加运算（虽然机器指令中可能有这种字节相加指令）。
	//所以，表达式中各种长度可能小于int长度的整型值，都必须先转换为int或unsigned int，然后才能送入CPU去执行运算。
	//char a = 3;//char有符号
	////00000011 - a 符号位为0 - 没有达到int型，需要高位补0提升为整型
	////00000000 00000000 00000000 00000011
	//char b = 127;
	////01111111 - b 符号位为0 - 没有达到int型，需要高位补0提升为整型
	////00000000 00000000 00000000 01111111
	//char c = a + b;
	////a和b都没有达到int大小，这时会发生整型提升,整型提升是按照变量的数据类型的符号位来提升的（符号位是什么就全补什么）
	////若数据类型为无符号，高位补0.
	////00000000 00000000 00000000 00000011 - a
	////00000000 00000000 00000000 01111111 - b
	////00000000 00000000 00000000 10000010 - a+b
	////10000010 - c	char只有8个比特位，因此截断低8位，但要打印%d，因此也需要整型提升
	////11111111 11111111 11111111 10000010	补
	////11111111 11111111 11111111 10000001	反
	////10000000 00000000 00000000 01111110	原 = -126

	//printf("%d\n", c);
	//若char ch = -1;
	//11111111 - ch 符号位为1，整型提升全补1
	//11111111 11111111 11111111 11111111 - 提升后的结果

	//char a = 0xb6;
	////10110110 - a
	////11111111 11111111 11111111 10110110 - 整型提升后的a
	////00000000 00000000 00000000 10110110 - 0xb6 != a
	//short b = 0xb600;
	////10110110 00000000	- b
	////11111111 11111111 10110110 00000000 - 整型提升后的b
	////00000000 00000000 10110110 00000000 - 0xb600 != b
	//int c = 0xb6000000;
	////10110110 00000000 00000000 00000000 - c
	////10110110 00000000 00000000 00000000 - 0xb6000000 = c
	//if (a == 0xb6)
	//	printf("a");
	//if (b == 0xb600)
	//	printf("b");
	//if (c == 0xb6000000)
	//	printf("c");

	//char c = 1;
	//printf("%u\n", sizeof(c));//sizeof返回无符号整数，%u用于打印无符号整数
	//printf("%u\n", sizeof(+c));//+c参与运算了（sizeof虽然是编译时，括号内表达式不参与运算，但是可以推导出其类型属性），发生了整型提升
	//printf("%u\n", sizeof(-c));//-c参与运算了，发生了整型提升
	//任何一个表达式都有两种属性：1.值属性（就是最后的值）	2.类型属性，计算机可以推导出来

	//2.算术转换：下列操作符的操作数若是不同的类型，需要向上转换，否则无法计算。
	//int - unsigned int - long int - unsigned long int - float - double - long double 依次向上转换

	//3.操作符属性：1.优先级	2.结合性(L-R || R-L 从左到右或从右到左) 	3.是否控制求值顺序



	return 0;
}