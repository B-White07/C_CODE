#define _CRT_SECURE_NO_WARNINGS 1
#include"utils.h"

int main()
{
	/*
		一、数据的存储：1.整形的存储	2.浮点型的存储
		分类：整型			浮点型		构造类型(自定义类型)：数组、结构体、枚举、联合体
			  指针类型		空类型：void、可用于函数返回值void test()、函数参数void test(void)、指针void* p
		整形取值范围定义位置：limits.h		浮点型取值范围定义位置：float.h
	*/
	//int arr1[10];//arr1类型：int [10]
	//int arr2[5];//arr2类型：int [5]
	//数据在内存中以二进制的补码形式存储，对于整数来说，其二进制有三种表示形式：原码反码和补码
	//正整数三码相同。负整数需要计算
	//1.整形的存储：char：unsigned/signed		short：unsigned/signed		int：unsigned/signed		long：unsigned/signed
	//为什么整数在内存中存储补码？cpu只有加法器而没有减法
	//使用补码可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理(cpu只有加法器而没有减法器)，
	//此外，补码与原码相互转换，其运算过程是相同的（其实补码除符号位按位取反+1得到的也是原码），不需要额外的硬件电路
	//1+(-1)若按照原码计算为-2
	
	//int a = -10;//小端存储
	//int b = 10;//小端存储
	////大端字节序和小端字节序(以字节为单位考虑存储顺序)
	//int c = 0x11223344;//小端存储
	//大端字节序：把数据的低位字节序的内容存放在高地址处，高位字节序的内容存放在低地址处
	//小端字节序：把数据的地位字节序的内容存放在低地址处，高位字节序的内容存放在高地址处

	//if (1 == byteSqu())
	//	printf("小端");
	//else
	//	printf("大端");

	//题
	//1.
	//char a = -1;
	//signed char b = -1;
	//unsigned char c = -1;
	////10000000 00000000 00000000 00000001 -> 11111111 11111111 11111111 11111110 -> 11111111 11111111 11111111 11111111
	////-> 11111111 - a -(整型提升) 11111111 11111111 11111111 11111111 = -1
	////11111111 - b -(整型提升) 11111111 11111111 11111111 11111111 = -1
	////11111111 - c -(整型提升) 00000000 00000000 00000000 11111111 = 2^8 - 1 = 255
	//printf("%d %d %d", a, b, c);
	//补充：
	//1.char类型到底是signed char还是unsigned char？ -- C语言标准没有规定，取决于编译器，大部分都是signed
	//2.int 和 short 默认均为signed

	//2.
	//char a = -128;
	////10000000 00000000 00000000 10000000
	////11111111 11111111 11111111 01111111
	////11111111 11111111 11111111 10000000
	////10000000 - a(整型提升，注意是按照原变量的类型确定符号) - 11111111 11111111 11111111 10000000 - 在%u的视角下，此数为正数，其补码就是原码
	//printf("%u\n", a);//4294967168

	//3.
	//char a = 128;
	//printf("%u\n", a);//同上
	//补充：char类型的取值范围：有符号 -128-127 （10000000被解析成-128）,char的环形示意图：127 + 1 = -128 
	//无符号：0-255
	//注意存的是补码，需要转换

	//4.
	//int i = -20;
	//unsigned int j = 10;
	////10000000 00000000 00000000 00010100 -> 11111111 11111111 11111111 11101100
	////00000000 00000000 00000000 00001010
	////11111111 11111111 11111111 11101100
	////11111111 11111111 11111111 11110110 -> 100000000 00000000 00000000 00001010 = -10
	//printf("%d\n", i + j);

	//5.
	//unsigned int i = 0;
	//for (i = 9; i >= 0; i--)
	//	printf("%u\n", i);//打印是正负再打印的时候不取决于i本身，而是取决于打印的格式

	//6.
	//char a[1000];
	//int i = 0;
	//for (i = 0; i < 1000; i++)
	//	a[i] = -1 - i;
	////-1 -2 -3 ... -128 127 126 ... 1 0 -1 -2 -3 ...
	//printf("%d", strlen(a));//255
	//char:超出范围的数据若为正数，-256；若为负数，+256

	//7.
	//unsigned char i = 0;
	//for (i = 0; i <= 255; i++)
	//	printf("hello world\n");

	//2.浮点数的存储
	//浮点数和整数在内存中的存储方式有区别
	//int n = 9;
	////00000000 00000000 00000000 00001001
	//float* pFloat = (float*)&n;
	//printf("n的值为：%d\n", n);
	//printf("*pFloat的值为：%f\n", *pFloat);//以浮点数的视角打印结果
	////		S    E               M
	////存：	0 00000000 00000000000000000001001
	////取：	M:0.00000000000000000001001		E:1-127=-126	-->  0.00000000000000000001001 * 2^-126	 -->  0.000000
	//*pFloat = 9.0;//以浮点数的视角存储9.0
	////1001.0
	////1.001 * 2^3
	////			S	 E				 M
	////存：		0 10000010 00100000000000000000000
	////取(int)： 01000001 00010000 00000000 00000000
	//printf("n的值为：%d\n", n);
	//printf("*pFloat的值为：%f\n", *pFloat);

	//IEEE754标准规定，任意一个二进制浮点数V可以表示成下边的形式：
	//1. (-1)^S * M * 2^E
	//2. (-1)^S 表示符号位，当S=0，v为正数；当S=1,v为负数
	//3. M表示有效数字，大于等于1，小于2；
	//4. 2^E表示指数位
	//5.5 -- 10进制浮点数
	//二进制：101.1 --> 1.011*2^2 --> (-1)^0 * 1.011 * 2^2 :S=0,M=1.011,E=2
	//对于32位浮点数，即float，最高的1位是符号位S，接着的8位是指数E，剩下的23位为有效数字M
	//对于64位浮点数，即double，最高的1位是符号位S，接着的11位是指数E，剩下的52位为有效数字M
	//M：由于1<=M<2,因此M小数点前面必为1，没有存储的必要，因此只存储小数点后边的数字
	//E：E为无符号整数，存入内存时E的真实值必须再加上一个中间数。若E为8位，这个中间数是127；若E为11位，这个中间数为1023。
	//float f = 5.5f;
	//101.1
	//1.011 * 2^2
	//S=0,M=1.011,E=2
	//S=0,M=011,E=2+127=129
	//01000000101100000000000000000000
	//01000000 10110000 00000000 00000000
	//40 b0 00 00

	//指数E从内存中取出可以再分为3种情况：
	//1.E不全为1且不全为0：E(真实) = E-127(1023)，再将有效数字M前加上第一位的1。
	//2.E为全0：真实的E偏小，规定E(真实)=1-127(1023)，有效数字M不再加上第一位的1，而是还原为0.xxxxxx的小数，来表示+正负0或很接近0的很小的数字。
	//3.E全为1：表示正负无穷大(正负取决于符号位S)


	/*
		二、指针
		1.字符指针		2.数组指针		3.指针数组		4.数组传参和指针传参		5.函数指针
		6.函数指针数组	7.指向函数指针数组的指针		8.回调函数		9.指针和数组面试题的解析
	*/
	//1.字符指针
	//char ch = 'q';
	//char* pc = &ch;
	//char* ps = "hello world";//本质上是把字符串的首字符地址存储在了ps中
	//*ps = 'w';//err，常量不能改
	//char arr[] = "hello world";
	//printf("%c\n", *ps);
	//printf("%s\n", ps);
	//printf("%s\n", arr);

	//char str1[] = "hello world.";
	//char str2[] = "hello world.";
	//const char* str3 = "hello world.";
	//const char* str4 = "hello world.";//"hello world."是常量字符串，在内存中只有一份。两个指针指向同一空间
	//if (str1 == str2)
	//	printf("str1 and str2 are same\n");
	//else
	//	printf("str1 and str2 are not same\n");
	//if (str3 == str4)
	//	printf("str3 and str4 are same\n");
	//else
	//	printf("str3 and str4 are not same\n");


	//2.指针数组：是存放指针的数组
	//int *arr[3];//存放整型指针的数组
	//int a = 10;
	//int b = 20;
	//int c = 30;
	//int* arr[3] = { &a,&b,&c };
	//for (int i = 0; i < 3; i++)
	//	printf("%d ", *(arr[i]));

	//int a[5] = { 1,2,3,4,5 };
	//int b[] = { 2,3,4,5,6 };
	//int c[] = { 3,4,5,6,7 };

	//int* arr[3] = { a,b,c };
	//for (int i = 0; i < 3; i++)
	//{
	//	for (int j = 0; j < 5; j++)
	//		printf("%d ", *(arr[i] + j));
	//		//printf("%d ",arr[i][j]);
	//	printf("\n");
	//}

	//3.数组指针

	//4.数组传参和指针传参
	//5.函数指针
	//6.函数指针数组
	//7.指向函数指针数组的指针
	//8.回调函数
	//9.指针和数组面试题的解析

	return 0;
}