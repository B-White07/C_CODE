#define _CRT_SECURE_NO_WARNINGS 1
#include "utils.h"



int main()
{
	/*
		一、指针
		1.指针是什么	2.指针和指针类型	3.野指针	4.指针运算	5.指针和数组	6.二级指针	7.指针数组
	*/
	//1.指针就是地址
	//int a = 10;
	//int* pa = &a;//拿到的是a的4个字节中的第一个字节
	//*pa = 20;

	//2.指针和指针类型
	//int *pa;
	//char *pc;
	//float *pf;
	//printf("%d\n", sizeof(pa));
	//printf("%d\n", sizeof(pc));
	//printf("%d\n", sizeof(pf));

	//指针类型的意义：
	//	1.指针类型决定了：指针解引用的权限有多大
	//int a = 0x11223344;
	//char *pc = &a;
	//*pc = 0;//由于pc为char类型指针，因此此处只能访问一个字节，将其改为0
	/*int *pa = &a;
	*pa = 0;*/

	//	2.指针类型决定了指针走一步能走多远（步长）
	//int arr[10] = { 0 };
	//int* p = arr;
	//char* pc = arr;
	//printf("%d\n", p);
	//printf("%d\n", p + 1);
	//printf("%d\n", pc);
	//printf("%d\n", pc + 1);

	//int arr[10] = { 0 };
	////int* p = arr;//跳过4个字节，即以元素为单位访问
	//char* p = arr;//一个字节一个字节改变
	//for (int i = 0; i < 10; i++)
	//{
	//	*(p + i) = 1;
	//}

	//3.野指针：指针指向的位置是不可知的（随机的、不正确的，没有明确权限的）
	//造成野指针的原因：
	//	1.指针未初始化
	//int* p;//p是一个局部变量，局部变量不初始化的话，默认的是随机值
	//*p = 20;//非法访问内存了，这里的p就是一个野指针

	//	2.指针越界访问
	//int arr[10] = 0;
	//int* p = arr;
	//for (int i = 0; i <= 10; i++)
	//{
	//	*p = i;
	//	p++;
	//}

	//	3.指针指向的空间释放
	/*int* p = test();
	*p = 20;*/

	//	4.避免野指针
	//		1.初始化
	//int* p = NULL;//当前不知道p应该初始化为什么地址的时候，直接初始化为NULL
	//int a = 10;
	//int* p = &a;//明确知道初始化的值
	//		2.小心越界，C语言本身是不会检查越界行为的
	//		3.指针指向空间被释放时，即使将指针置空
	//		4.指针使用之前进行有效性检查
	//int* p = NULL;
	//if(p != NULL)
	//	*p = 50;

	//4.指针运算
	//	1.指针+-整数
	//int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	//int* p = arr;
	//int* pend = arr + 9;
	//while (p <= pend)//指针关系运算
	//{
	//	printf("%d\n", *p);
	//	p++;
	//}
	//	2.指针-指针：前提是两个指针指向同一块空间		指针+指针无意义
	//int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	//printf("%d", &arr[9] - &arr[0]);//指针减指针，得到指针之间元素的个数

	//int len = myStrlen("abc");
	//int len = myStrlen2("abc");
	//printf("%d\n", len);
	//	3.指针的关系运算，标准规定：允许指向数组元素的指针与指向数组最后一个元素和后边的那个内存位置的指针比较
	//								但是不允许与指向第一个元素之前的那个内存位置的指针进行比较。
	/*for (vp = &values[N_VALUES]; vp > &values[0])
		*--vp = 0;*/

	//5.指针和数组
	//int arr[10] = { 0 };
	//printf("%p\n", arr);//数组名是首元素地址
	//printf("%p\n", &arr[0]);
	//int* p = arr;
	//for (int i = 0; i < 10; i++)
	//{
	//	printf("%p <==> %p\n", &arr[i], p + i);
	//	*(p + i) = i;
	//}
	//for (int i = 0; i < 10; i++)
	//	printf("%d ", *(p + i));

	//int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	//int* p = arr;//数组名
	////[]是一个操作符	2和arr是两个操作数
	//printf("%d\n", 2[arr]);	//arr[2] --> *(arr+2) <==> *(2+arr) --> 2[arr]
	//printf("%d\n", arr[2]);
	//printf("%d\n", p[2]); //p[2] --> *(p+2) <==> *(2+p) --> 2[p]
	////arr[2] <==> *(arr+2) <==> *(p+2) <==> *(2+p) <==> *(2+arr)
	////2[arr] <==> *(2+arr)

	//6.二级指针
	//int a = 10;
	//int* pa = &a;//pa是指针变量，一级指针
	//int* *ppa = &pa;//pa也是变量，&pa取出pa在内存中的起始地址,ppa就是一个二级指针变量
	//int** *pppa = &ppa;

	//7.指针数组
	//int arr[10];//整型数组 - 存放整形的数组
	//char ch[5];//字符数组 - 存放字符的数组
	////指针数组 - 存放指针的数组
	//int* parr[5];//整型指针的数组
	//char* pch[5];//字符指针的数组


	/*
		二、结构体：一些值的集合，这些值可以是不同类型的
	*/
	//struct Stu s = { {'w',20,3.14},"张三",20,"001" };//对象，局部变量
	//////	. ->
	////printf("%c\n", s.b.c);
	////printf("%s\n", s.id);
	//struct Stu* ps = &s;
	////printf("%c\n",(*ps).b.c);
	////printf("%c\n", ps->b.c);

	////写一个函数打印s的内容
	//print1(s);//传值调用
	//print2(ps);//传址调用，效率较高

	/*函数调用的参数压栈
		栈，先进后出，后进先出。
		每一个函数调用都会在内存的栈区开辟一块空间。
		通常情况下，传参是从右向左传递的
	*/
	/*int a = 3;
	int b = 4;
	int c = 0;
	c = Add(a, b);*/
	

	//一些小问题
	//int i = 0 //再此定义i和在括号内定义结果不同
	//int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
	// i和arr是局部变量，放在栈区上的。栈区内存的使用习惯是先使用高地址空间，再使用低地址空间。
	// 而数组随着下标的增长，地址是由低到高变化的，因此可能导致死循环，导致死循环时，无法停下，所以不报错。运行时报错得在运行结束以后
	// 不同编译器空的整形个数不一样，由编译器决定。
	//for (int i = 0; i <= 12; i++)
	//{
	//	arr[i] = 0;
	//	printf("hello\n");
	//}

char arr1[20] = "xxxxxxxxxx";
char arr2[] = "hello";
myStrcpy(arr1, arr2);
printf("%s", arr1);


	return 0;
}